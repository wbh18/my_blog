{"meta":{"title":"吴老狗的小站","subtitle":"","description":"","author":"Wu","url":"http://wbhfe.com","root":"/"},"pages":[{"title":"Archives","date":"2020-05-08T10:53:17.255Z","updated":"2020-05-08T10:53:17.255Z","comments":true,"path":"archives/index.html","permalink":"http://wbhfe.com/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-05-08T10:53:17.255Z","updated":"2020-05-08T10:53:17.255Z","comments":false,"path":"categories/index.html","permalink":"http://wbhfe.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-05-08T10:53:17.257Z","updated":"2020-05-08T10:53:17.257Z","comments":true,"path":"tags/index.html","permalink":"http://wbhfe.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Promise 常见API总结","slug":"Promise 常见API总结","date":"2020-05-08T09:23:55.000Z","updated":"2020-05-08T10:53:17.254Z","comments":true,"path":"2020/05/08/Promise 常见API总结/","link":"","permalink":"http://wbhfe.com/2020/05/08/Promise%20%E5%B8%B8%E8%A7%81API%E6%80%BB%E7%BB%93/","excerpt":"Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。本文是对常见的promise方法的一个记录。","text":"Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。本文是对常见的promise方法的一个记录。 Promise.then 1promise.then(onFulfilled, onRejected) then 代码示例 1234567891011var promise = new Promise(function(resolve, reject) &#123; resolve('传递给then的值')&#125;)promise.then( function(value) &#123; console.log(value) &#125;, function(error) &#123; console.error(error) &#125;) 这段代码创建了一个promise对象，定义了处理onFulfilled和onRejected的函数(handler)，然后返回这个promise对象，这个promise对象会在变为resolve或者reject的时候分别调用相应注册的回调函数。也就是说，当handler返回正常值的时候，这个值会传递给promise对象的onFullfilled方法，如果handler中产生异常，则会将这个值传递给promise对象的onRejected方法 Promise.catch 1promise.then(onRejected) catch代码示例 12345678var promise = new Promise(function(resolve, reject)&#123; resolve(\"传递给then的值\");&#125;);promise.then(function (value) &#123; console.log(value);&#125;).catch(function (error) &#123; console.error(error);&#125;); 这是一个等价于promise.then(undefined, onRejected)的语法糖 Promise.resolve 123Promise.resolve(promise);Promise.resolve(thenable);Promise.resolve(object); Promise.resolve代码示例 1234567891011var taskName = \"task 1\"asyncTask(taskName).then(function (value) &#123; console.log(value);&#125;).catch(function (error) &#123; console.error(error);&#125;);function asyncTask(name)&#123; return Promise.resolve(name).then(function(value)&#123; return \"Done! \"+ value; &#125;);&#125; 根据接收参数的不同，返回不同的Promise对象。虽然说每一种情况都会返回Promise对象，但是大致分为以下三类：1、当接收到Promise对象参数的时候，返回的也是接收到的Promise对象2、当接收到thenable类型的对象的时候，返回的是一个新的Promise对象，该对象具有then方法3、当接收到的参数为其他类型时，返回一个将该对象作为值的新的Promise对象 Promise.reject 1Promise.reject(object) Promise.reject代码示例 12var failureStub = sinon.stub(xhr, \"request\").returns(Promise.reject(new Error(\"bad!\")));//sinon.js用以伪造xhr请求以测试 返回一个使用接收到的值进行了reject的新的promise对象传给Promise。reject的值也是一个Error类型的对象另外，和Promise.resolve不同的是，即使Promise.reject接收到的对象是一个Promise对象，依旧会返回一个全新的Promise对象 Promise.all 1Promise.all(promiseArray); Promise.all代码示例 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); 生成并返回一个新的promise对象，参数传递所有promise对象都变为resolve的时候，该方法才会返回，而新生成的promise则会使用这些promise的值，如果参数中任意一个promise为reject的话，那么Promise.all会立刻终止，并返回一个reject的新的promise对象。由于参数数组中每一个元素都是有Promise.resolve包装的，所以Promise.all可以处理不同类型的Promise对象 Promise.race 1Promise.race(promiseArray) Promise.race代码示例 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value); // 1&#125;); 生成并返回一个新的promise对象，参数promise数组中的任何一个promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个promise对象的值进行resolve或者reject","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://wbhfe.com/categories/Javascript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://wbhfe.com/tags/promise/"},{"name":"异步","slug":"异步","permalink":"http://wbhfe.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"Javascript 事件执行机制","slug":"Javascript 事件执行机制","date":"2020-05-08T06:55:55.000Z","updated":"2020-05-08T10:53:17.254Z","comments":true,"path":"2020/05/08/Javascript 事件执行机制/","link":"","permalink":"http://wbhfe.com/2020/05/08/Javascript%20%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。归根结底还是因为js是一门单线程语言。在此总结一篇关于js事件执行机制的笔记。","text":"JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。归根结底还是因为js是一门单线程语言。在此总结一篇关于js事件执行机制的笔记。 Javascript 事件循环Javascript 任务：同步任务 异步任务 123456789101112st&#x3D;&gt;start: 任务进入执行栈e&#x3D;&gt;end: 读取任务队列中的结果，进入主线程执行cond&#x3D;&gt;condition: 是否是同步任务op1&#x3D;&gt;operation: 主线程op2&#x3D;&gt;operation: Event Tableop3&#x3D;&gt;operation: 任务全部执行完毕op4&#x3D;&gt;operation: Event Queue io&#x3D;&gt;inputoutput: 注册回调函数 st-&gt;condcond(yes)-&gt;op1-&gt;op3-&gt;econd(no)-&gt;op2-&gt;io-&gt;op4-&gt;e 1、同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。2、当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。3、主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。4、上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 关于 setTimeout有些时候会发现 setTimeout 的延时执行假若只设置为 3 秒，但是实际上等待的时间可能会比 3 秒要长，正是因为同步的单线程任务需要一个个执行，如果执行的时间太久，则会影响 setTimeout 的执行，必须等待主线程内的任务执行完毕才会执行。因此不难解释 setTimeout(fn,0)，它的含义是，指定某个任务在主线程最早可得的空闲时间执行，大意是当主线程执行栈内的同步任务全部执行完成，栈为空就会马上执行。 关于 setInterval和 setTimeout 有相似之处，不过 setInterval 是循环执行。setInterval 会每隔指定的时间将注册的函数放入 Event Queue 中，如果前面的任务耗费的时间太久，那么也同样的需要等待。需要注意的是对于 setInterval(fn, ms)来说，一旦 setInterval 的回调函数 fn 的执行时间超过了延迟时间 ms，那将会完全看不出来有时间间隔。 Promise与process.nextTick(callback)除了广义的同步任务和异步任务，我们对于任务有着更为精细的定义： macro-task(宏任务): 包括整体的代码script、setTimeout、setIntervalmicro-task(微任务): Promise,process.nextTick 不同类型的任务会进入对应的Event Queue，比如说setTimeout和setInterval会进入相同的Event Queue 事件循环的顺序决定了js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。 123456789st&#x3D;&gt;start: 宏任务e&#x3D;&gt;end: 执行所有微任务op1&#x3D;&gt;operation: 执行结束op2&#x3D;&gt;operation: 开始新的宏任务op3&#x3D;&gt;operation: 没有的话，开始新的宏任务cond&#x3D;&gt;condition: 有可执行的微任务吗(yes or no)st-&gt;op1-&gt;cond(yes)-&gt;e-&gt;op2cond(no)-&gt;op3-&gt;st 利用一段代码说明这个过程： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。遇到console.log()，立即执行。好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。结束。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://wbhfe.com/categories/Javascript/"}],"tags":[{"name":"js原理","slug":"js原理","permalink":"http://wbhfe.com/tags/js%E5%8E%9F%E7%90%86/"}]}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://wbhfe.com/categories/Javascript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://wbhfe.com/tags/promise/"},{"name":"异步","slug":"异步","permalink":"http://wbhfe.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"js原理","slug":"js原理","permalink":"http://wbhfe.com/tags/js%E5%8E%9F%E7%90%86/"}]}